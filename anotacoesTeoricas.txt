-------------------------------- Conceitos teóricos abaixo

Convenção: Nome de classe, propriedade e método -> Pascal Case (sem espaços, e primeira letra maiúscula)
o nome do arquivo físico deve ser o mesmo nome da classe
não pode abreviações, para ser o mais claro possível, ex: NomeRepLegalPessoaFis
o certo seria: NomeRepresentanteLegalDaPessoaFisica (mesmo que seja grande)
pra caso outra pessoa for fazer manutenção no seu código, ela conseguir entender
nome de variável é Camel Case -> começa com minúscula e palavras compostas são escritas juntas sem espaços, com a primeira letra de cada palavra subsequentemente capitalizada
sem caractere especial nos nomes, apenas underline é aceito

tipos de dados:
string = série de caracteres
char = um único caractere
object = objeto
bool = booleano (true or false)
int = números inteiros (ele tem limite mas é alto)
uint = a diferença entre int e uint é que uint usa os 32 bits pra representar numeros positivos
long = inteiros que vão mais longe que int
ulong é de 64 bit (o dobro de uint e é só positivos)
byte vai de 0 a 255
para números decimais:
decimal é recomendável quando é dinheiro, é mais preciso quando se tem valores monetários
float é para os decimais como o int é para os inteiros
double é para os decimais como o long é para os inteiros
principais utilizados: string, object, bool, int, decimal e double

quando atribuímos diretamente um valor à uma variável decimal, exemplo: "decimal preco = 1.99;" receberemos o seguinte erro: "Literal do tipo double não pode ser convertido implicitamente no tipo "decimal"; use um sufixo "M" para criar um literal desse tipo", então, quando for atribuir de forma literal deve-se utilizar o sufixo "M", resultando em: "decimal preco = 1.99M;"

para não perder o 0 em um exemplo como: "double altura = 1.60;" na hora de printar pode-se estar fazendo o seguinte tratamento: "Console.WriteLine("Valor da variável altura: " + altura.ToString("0.00"));", mas o ideal seria estar utilizando decimal para não ter que ficar tratando posteriormente, por isso a escolha do tipo da variável implica tanto nos resultados

variáveis são feitas para mudarem de valor durante o código, como o próprio nome já diz, não pode declarar uma variável com nome exatamente igual a outra no mesmo escopo de código

para trabalhar com data no C# utilizamos DateTime como o exemplo a seguir:
"DateTime dataAtual = DateTime.Now;", pode ser feita até soma de dias, meses, anos, milissegundos através do Add, como podemos ver a seguir o exeplo que pega a data e hora atual e soma 5 dias: "DateTime dataAtual = DateTime.Now.AddDays(5);", pode fazer data1 - data2, sempre utilizando DateTime. Tem com mudar a visualização da data utilizando: "Console.WriteLine(dataAtual.ToString("dd/MM/yyyy"));"

int a = "5";
isso dá errado pois não pode atribuir string em um inteiro sem converter

Casting é a conversão do tipo
int a = Convert.ToInt32("5");
int a = int.Parse("5");
aqui ocorre a conversão de uma string em int
Use int.Parse quando você tem certeza que a string não é nula e sempre será um número válido.
Use Convert.ToInt32 quando pode vir null ou quando trabalha com objetos de tipos variados.

Para converter para string:
int inteiro = 5;
string b = inteiro.ToString();
Tem o ToString para todos os tipos, pois o parse não tem e é melhor que o convert

Casting implícito:
int a = 5;
double b = a;
inteiro cabe no double, faz a conversão sozinho

long.MaxValue é o maior número suportado por um long

C# vai seguir a ordem dos operadores
4 / 2 + 2
nesse o 4 / 2 vem primeiro
depois soma com 2

string palavra = "15";
int b = 0;

int.TryParse(palavra, out b);
aqui ele tenta converter a palavra
se der erro ele não para todo o programa
se não der erro, é atribuído ao b
Poderia criar a variável ali no out mesmo:
int.TryParse(palavra, out int c);

int quantidade1 = 10;
int quantidade2 = 4;
bool condicao = quantidade1 >= quantidade2;
a variável condicao irá receber true ou false

colocando um pontinho vermelho na linha
e apertando F5 dá pra debugar

como fazer um array em C#:
int[] arrayInteiros = new int[3];

arrayInteiros[0] = 72;
arrayInteiros[1] = 64;
arrayInteiros[2] = 50;

Console.WriteLine("percorrendo o array com for") ;
for (int contador = 0; contador < arrayInteiros.Length; contador++)
{
    Console.WriteLine($"Posição número {contador} - {arrayInteiros[contador]}");
}

Console.WriteLine("percorrendo o array com foreach") ;
foreach (int valor in arrayInteiros)
{
    Console.WriteLine(valor);
}

precisa do valor do índice(contador)? melhor utilizar o for, se não, foreach

Para lidar com redimencionamento de arrays podemos estar utilizando:

Array.Resize(ref arrayInteiros, arrayInteiros.Length * 2);

por baixo dos panos o resize vai criar um novo array com o tamanho redefinido e irá copiar os elementos do antigo array

para copiar os valores de um array ao outro dá para utilizar Array.Copy:

Array.Copy(arrayInteiros, arrayInteirosDobrado, arrayInteiros.Length);

o que ele faz de diferente do resize é que no resize você usa o mesmo array, no copy precisa obrigatoriamente de um novo

Já para listas não é necessário definir um tamanho exato

List<string> listaString = new List<string>();

listaString.Add("SP");
listaString.Add("BA");
listaString.Add("MG");
listaString.Add("RJ");

Console.WriteLine($"Itens na minha lista: {listaString.Count} - Capacidade: {listaString.Capacity}");

listaString.Add("SC");

Console.WriteLine($"Itens na minha lista: {listaString.Count} - Capacidade: {listaString.Capacity}");

listaString.Remove("MG");

Console.WriteLine($"Itens na minha lista: {listaString.Count} - Capacidade: {listaString.Capacity}");

Console.WriteLine("Percorrendo a lista com for");
for (int contador = 0; contador < listaString.Count; contador++)
{
    Console.WriteLine($"Posição Nº {contador} - {listaString[contador]}");
}

Console.WriteLine("Percorrendo a lista com foreach");
int contadorForeach = 0;
foreach (string item in listaString)
{
    Console.WriteLine($"Posição Nº {contadorForeach} - {item}");
    contadorForeach++;
}